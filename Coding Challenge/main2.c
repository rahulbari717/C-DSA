/*
TO DO :- 
Task:
Your task is only to write the packet_decode function, without editing or creating any other functions in the code. The function should receive packets of varying lengths and decode them if they match the intended device ID.
Packets may arrive out of order and will need to be reassembled based on the packet number.
Once all packets are received, your code should assemble the data in order and pass it as a single uint8_t array to the process_data function for validation and display.

*/

#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Global variables to store packet data
#define MAX_PACKETS 16
#define MAX_DATA_SIZE 512
static uint8_t* packet_data[MAX_PACKETS] = {0};
static uint16_t packet_lengths[MAX_PACKETS] = {0};
static uint16_t total_data_size = 0;
static uint8_t* assembled_data = NULL;

// Function to handle processed data once assembled
void process_data(uint8_t *assembled_data) {
    printf("Processed data: \n\n%s\n\n", assembled_data);
    printf("\nEnter the characters shown in above image in the form 2\n");
}

/*
Packet Structure:
Each packet has the following fields:

Header 
Size (Bytes): 1
Description: Start of the packet. The value is 0xAA.
Total Length
Size (Bytes): 1
Description: Total length of the packet (including header, footer, and all fields)
Device ID
Size (Bytes): 1
Description: Identifies the intended recipient of the packet. You need to write the code for the device id 0x01.
Packet Number
Size (Bytes): 2
Description: Packet number, used to reassemble data in the correct order. Sent with the Most Significant Byte (MSB) first.
Total Data Size
Size (Bytes): 2
Description: Total size of the complete data payload across all packets, sent with MSB first. This field is consistent across packets and serves to verify when the entire data is received.
Data Part
Size (Bytes): Variable
Description: Part of the actual data to be assembled
Checksum
Size (Bytes): 1
Description: XOR of all bytes in the packet (excluding header, footer, and checksum field itself) for data integrity verification
Footer
Size (Bytes): 1
Description: End of the packet. The value is 0xBB.

*/



void packet_decode(const uint8_t *packet) {
    // packet_decode function for candidate to complete

    // Check header and footer
    if (packet[0] != 0xAA || packet[packet[1] - 1] != 0xBB) {
        return;
    }

    // Extract fields
    uint8_t total_length = packet[1];
    uint8_t device_id = packet[2];
    uint16_t packet_num = (packet[3] << 8) | packet[4];
    uint16_t data_size = (packet[5] << 8) | packet[6];

    // Filter by device ID
    if (device_id != 0x01) {
        return;
    }

    // Verify checksum
    uint8_t checksum = 0;
    for (uint8_t i = 1; i < total_length - 2; i++) {
        checksum ^= packet[i];
    }
    if (checksum != packet[total_length - 2]) {
        return;
    }

    // Store total data size
    if (total_data_size == 0) {
        total_data_size = data_size;
    }

    // Calculate data length and store packet data
    uint8_t data_length = total_length - 9; // Subtract header, length, device_id, packet_num(2), total_data_size(2), checksum, footer
    if (packet_num < MAX_PACKETS) {
        if (packet_data[packet_num] == NULL) {
            packet_data[packet_num] = malloc(data_length);
            memcpy(packet_data[packet_num], &packet[7], data_length);
            packet_lengths[packet_num] = data_length;
        }
    }

    // Check if all packets are received
    uint16_t received_data_size = 0;
    uint8_t packets_received = 0;
    for (int i = 0; i < MAX_PACKETS; i++) {
            if (packet_data[i] != NULL) {
            received_data_size += packet_lengths[i];
            packets_received++;
        }
    }

    // Assemble data when complete
    if (received_data_size >= total_data_size && packets_received > 0) {
        if (assembled_data == NULL) {
            assembled_data = malloc(total_data_size);
            uint16_t offset = 0;
            for (int i = 0; i < MAX_PACKETS; i++) {
                if (packet_data[i] != NULL) {
                    memcpy(assembled_data + offset, packet_data[i], packet_lengths[i]);
                    offset += packet_lengths[i];
                }
            }
            process_data(assembled_data);
            
            // Clean up
            for (int i = 0; i < MAX_PACKETS; i++) {
                if (packet_data[i] != NULL) {
                    free(packet_data[i]);
                    packet_data[i] = NULL;
                }
            }
            free(assembled_data);
            assembled_data = NULL;
            total_data_size = 0;
        }
    }
}

// Main function to call packet_decode with each simulated packet
int main() {
    // Simulating packet reception by calling packet_decode on each packet
    packet_decode((uint8_t[]){0xAA, 0x1F, 0x01, 0x00, 0x09, 0x01, 0x0C, 0x2D, 0x2D, 0x4F, 0x20, 0x6F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6F, 0x20, 0x20, 0x20, 0x6F, 0x20, 0x6F, 0x2D, 0x2D, 0x6F, 0x20, 0x20, 0x3A, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x18, 0x01, 0x00, 0x0A, 0x01, 0x0C, 0x2F, 0x20, 0x5C, 0x20, 0x20, 0x20, 0x6F, 0x20, 0x20, 0x20, 0x6F, 0x2D, 0x6F, 0x20, 0x0A, 0x25, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1F, 0x02, 0x00, 0x09, 0x01, 0x0C, 0x2D, 0x2D, 0x4F, 0x20, 0x6F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6F, 0x20, 0x20, 0x20, 0x6F, 0x20, 0x6F, 0x2D, 0x2D, 0x6F, 0x20, 0x20, 0x3A, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x18, 0x03, 0x00, 0x0A, 0x01, 0x0C, 0x2F, 0x20, 0x5C, 0x20, 0x20, 0x20, 0x6F, 0x20, 0x20, 0x20, 0x6F, 0x2D, 0x6F, 0x20, 0x0A, 0x25, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1D, 0x04, 0x00, 0x01, 0x01, 0x0C, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6F, 0x2D, 0x2D, 0x6F, 0x20, 0x20, 0x6F, 0x20, 0x20, 0x20, 0x6F, 0x20, 0x6F, 0x2D, 0x78, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1D, 0x01, 0x00, 0x01, 0x01, 0x0C, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6F, 0x2D, 0x2D, 0x6F, 0x20, 0x20, 0x6F, 0x20, 0x20, 0x20, 0x6F, 0x20, 0x6F, 0x2D, 0x78, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1B, 0x01, 0x00, 0x02, 0x01, 0x0C, 0x2D, 0x6F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6F, 0x20, 0x20, 0x20, 0x6F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x57, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1D, 0x01, 0x00, 0x0B, 0x01, 0x0C, 0x20, 0x20, 0x20, 0x7C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x46, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1D, 0x03, 0x00, 0x06, 0x01, 0x0C, 0x20, 0x20, 0x5C, 0x20, 0x2F, 0x20, 0x20, 0x20, 0x4F, 0x20, 0x20, 0x20, 0x6F, 0x2D, 0x6F, 0x20, 0x0A, 0x7C, 0x20, 0x20, 0x70, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1C, 0x04, 0x00, 0x07, 0x01, 0x0C, 0x7C, 0x20, 0x7C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7C, 0x20, 0x20, 0x5C, 0x7C, 0x20, 0x7C, 0x20, 0x20, 0x20, 0x7C, 0x4B, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1A, 0x05, 0x00, 0x08, 0x01, 0x0C, 0x20, 0x20, 0x6F, 0x20, 0x20, 0x20, 0x20, 0x7C, 0x20, 0x20, 0x20, 0x20, 0x2F, 0x20, 0x20, 0x0A, 0x6F, 0x47, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1F, 0x06, 0x00, 0x03, 0x01, 0x0C, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7C, 0x20, 0x20, 0x20, 0x7C, 0x20, 0x7C, 0x5C, 0x20, 0x20, 0x7C, 0x20, 0x7C, 0x20, 0x20, 0x20, 0x1A, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1A, 0x07, 0x00, 0x04, 0x01, 0x0C, 0x7C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5C, 0x20, 0x2F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0A, 0x37, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1E, 0x08, 0x00, 0x05, 0x01, 0x0C, 0x6F, 0x20, 0x20, 0x6F, 0x20, 0x4F, 0x2D, 0x2D, 0x6F, 0x20, 0x20, 0x7C, 0x20, 0x5C, 0x20, 0x7C, 0x20, 0x4F, 0x2D, 0x2D, 0x6F, 0x4B, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1B, 0x01, 0x00, 0x0C, 0x01, 0x0C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0A, 0x31, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1C, 0x01, 0x00, 0x0D, 0x01, 0x0C, 0x6F, 0x2D, 0x2D, 0x6F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3D, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1A, 0x01, 0x00, 0x0E, 0x01, 0x0C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x38, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x0C, 0x01, 0x00, 0x0F, 0x01, 0x0C, 0x20, 0x0A, 0x0A, 0x2F, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1D, 0x01, 0x00, 0x06, 0x01, 0x0C, 0x20, 0x20, 0x5C, 0x20, 0x2F, 0x20, 0x20, 0x20, 0x4F, 0x20, 0x20, 0x20, 0x6F, 0x2D, 0x6F, 0x20, 0x0A, 0x7C, 0x20, 0x20, 0x70, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1B, 0x05, 0x00, 0x02, 0x01, 0x0C, 0x2D, 0x6F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x6F, 0x20, 0x20, 0x20, 0x6F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x57, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1D, 0x06, 0x00, 0x0B, 0x01, 0x0C, 0x20, 0x20, 0x20, 0x7C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x46, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1B, 0x07, 0x00, 0x0C, 0x01, 0x0C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0A, 0x31, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1C, 0x08, 0x00, 0x0D, 0x01, 0x0C, 0x6F, 0x2D, 0x2D, 0x6F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x3D, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1A, 0x09, 0x00, 0x0E, 0x01, 0x0C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x38, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x0C, 0x02, 0x00, 0x0F, 0x01, 0x0C, 0x20, 0x0A, 0x0A, 0x2F, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1C, 0x01, 0x00, 0x07, 0x01, 0x0C, 0x7C, 0x20, 0x7C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7C, 0x20, 0x20, 0x5C, 0x7C, 0x20, 0x7C, 0x20, 0x20, 0x20, 0x7C, 0x4B, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1A, 0x01, 0x00, 0x08, 0x01, 0x0C, 0x20, 0x20, 0x6F, 0x20, 0x20, 0x20, 0x20, 0x7C, 0x20, 0x20, 0x20, 0x20, 0x2F, 0x20, 0x20, 0x0A, 0x6F, 0x47, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1F, 0x01, 0x00, 0x03, 0x01, 0x0C, 0x0A, 0x20, 0x20, 0x20, 0x20, 0x20, 0x7C, 0x20, 0x20, 0x20, 0x7C, 0x20, 0x7C, 0x5C, 0x20, 0x20, 0x7C, 0x20, 0x7C, 0x20, 0x20, 0x20, 0x1A, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1A, 0x01, 0x00, 0x04, 0x01, 0x0C, 0x7C, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x5C, 0x20, 0x2F, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x0A, 0x37, 0xBB});
    packet_decode((uint8_t[]){0xAA, 0x1E, 0x01, 0x00, 0x05, 0x01, 0x0C, 0x6F, 0x20, 0x20, 0x6F, 0x20, 0x4F, 0x2D, 0x2D, 0x6F, 0x20, 0x20, 0x7C, 0x20, 0x5C, 0x20, 0x7C, 0x20, 0x4F, 0x2D, 0x2D, 0x6F, 0x4B, 0xBB});

    return 0;
}
